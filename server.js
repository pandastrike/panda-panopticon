// Generated by CoffeeScript 1.7.1
(function() {
  var AWS, GenerateToken, OnRequest, OnUnsecuredRequest, UserSessions, file_server, fs, getRequests, http, https, key_size, node_static, options, postRequests, randomKey, root_directory, url;

  https = require("https");

  http = require("http");

  url = require("url");

  fs = require('fs');

  node_static = require('node-static');

  AWS = require('aws-sdk');

  randomKey = require('key-forge').randomKey;

  root_directory = ".";

  options = {
    key: fs.readFileSync(root_directory + '/security/privatekey.pem'),
    cert: fs.readFileSync(root_directory + '/security/certificate.pem')
  };

  file_server = new node_static.Server(root_directory + '/public');

  UserSessions = [];

  key_size = 32;

  OnUnsecuredRequest = function(request, response) {
    var host, new_url, path;
    host = request.headers.host;
    path = url.parse(request.url).pathname;
    new_url = "https://" + host + path;
    response.writeHead(301, {
      "Location": new_url
    });
    return response.end();
  };

  OnRequest = function(request, response) {
    if (request.method === "GET") {
      return getRequests(request, response);
    } else if (request.method === "POST") {
      return postRequests(request, response);
    } else {
      response.writeHead(400);
      response.write("Bad Request.  This HTTP verb is currently not supported.");
      return response.end();
    }
  };

  getRequests = function(request, response) {
    var pathname;
    pathname = url.parse(request.url).pathname;
    if (pathname === "/") {
      file_server.serveFile("./views/main.html", 200, {}, request, response);
    }
    return request.addListener('end', function() {
      return file_server.serve(request, response, function(error, result) {});
    }).resume();
  };

  postRequests = function(request, response) {
    var pathname;
    pathname = url.parse(request.url).pathname;
    if (pathname === "/login") {
      request.setEncoding('utf8');
      return request.on('data', function(chunk) {
        var creds, ec2, generated_token;
        creds = chunk.split(",");
        AWS.config = {
          accessKeyId: creds[0],
          secretAccessKey: creds[1],
          region: creds[2],
          sslEnabled: true
        };
        generated_token = GenerateToken();
        ec2 = new AWS.EC2();
        return ec2.describeInstances({}, function(error, data) {
          var i, instance_list, j, k, match_list, _i, _j, _k, _ref, _ref1, _ref2;
          if (error) {
            response.writeHead(502);
            response.write(error.message);
            return response.end();
          } else {
            instance_list = "";
            match_list = "";
            for (i = _i = 0, _ref = data.Reservations.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              for (j = _j = 0, _ref1 = data.Reservations[i].Instances.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                instance_list += data.Reservations[i].Instances[j].InstanceId;
                for (k = _k = 0, _ref2 = data.Reservations[i].Instances[j].Tags.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                  match_list += data.Reservations[i].Instances[j].Tags[k].Key + ": " + data.Reservations[i].Instances[j].Tags[k].Value;
                  if (k !== data.Reservations[i].Instances[j].Tags.length - 1) {
                    match_list += ",";
                  }
                }
                if (j !== data.Reservations[i].Instances.length - 1) {
                  instance_list += ",";
                  match_list += ";";
                }
              }
              if (i !== data.Reservations.length - 1) {
                instance_list += ",";
                match_list += ";";
              }
            }
            return ec2.describeTags({}, function(error, data) {
              var response_string, tag_list, temp, _l, _ref3;
              if (error) {
                response.writeHead(502);
                response.write(error.message);
                return response.end();
              } else {
                tag_list = "";
                for (i = _l = 0, _ref3 = data.Tags.length - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
                  tag_list += data.Tags[i].Key + ": " + data.Tags[i].Value;
                  if (i !== data.Tags.length - 1) {
                    tag_list += ",";
                  }
                }
                temp = {
                  token: generated_token.token,
                  expiration: generated_token.expiration,
                  credentials: AWS.config
                };
                UserSessions.push(temp);
                response_string = generated_token.token + ";" + instance_list + ";" + tag_list + ";" + match_list;
                response.writeHead(200);
                response.write(response_string);
                return response.end();
              }
            });
          }
        });
      });
    } else if (pathname === "/pull_metrics") {
      request.setEncoding('utf8');
      return request.on('data', function(chunk) {
        var cloudwatch, i, mini_chunks, params, time, token, token_found, _i, _ref;
        mini_chunks = chunk.split(";");
        token = mini_chunks[0];
        time = mini_chunks[1].split(",");
        token_found = false;
        for (i = _i = 0, _ref = UserSessions.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (UserSessions[i].token === token) {
            token_found = true;
            AWS.config = UserSessions[i].credentials;
            break;
          }
        }
        if (token_found === false) {
          response.writeHead(401);
          response.write("Access Denied:  Security clearance has expired or is invalid.");
          response.end();
          return;
        }
        cloudwatch = new AWS.CloudWatch();
        params = {
          StartTime: String(time[0]),
          EndTime: String(time[1]),
          Period: String(time[2]),
          Namespace: 'AWS/EC2',
          MetricName: String(mini_chunks[3]),
          Statistics: ['Average'],
          Dimensions: [
            {
              Name: 'InstanceId',
              Value: String(mini_chunks[2])
            }
          ]
        };
        return cloudwatch.getMetricStatistics(params, function(error, data) {
          var message, _j, _ref1;
          if (error) {
            response.writeHead(502);
            response.write(error.message);
            return response.end();
          } else {
            message = "";
            for (i = _j = 0, _ref1 = data.Datapoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              message += data.Datapoints[i].Timestamp + "," + data.Datapoints[i].Average;
              if (i < data.Datapoints.length - 1) {
                message += ";";
              }
            }
            response.writeHead(200);
            response.write(message);
            return response.end();
          }
        });
      });
    }
  };

  GenerateToken = function() {
    var d, expiration, temp_token;
    temp_token = randomKey(key_size);
    d = new Date();
    expiration = d.getTime();
    expiration += 24 * 60 * 60 * 1000;
    return {
      token: temp_token,
      expiration: expiration
    };
  };

  https.createServer(options, OnRequest).listen(443);

  http.createServer(OnUnsecuredRequest).listen(80);

}).call(this);
