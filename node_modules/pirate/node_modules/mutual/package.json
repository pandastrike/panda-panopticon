{
  "name": "mutual",
  "version": "0.4.16",
  "description": "Scala-inspired Actors that use Redis as a message transport",
  "main": "lib/index.js",
  "scripts": {
    "prepublish": "coffee -o lib/ -c src/*.coffee"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/dyoder/mutual.git"
  },
  "keywords": [
    "scala",
    "actor",
    "channel",
    "redis",
    "message",
    "distributed",
    "queue",
    "worker"
  ],
  "author": {
    "name": "Dan Yoder"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "dependencies": {
    "fairmont": "0.7.x",
    "generic-pool": "2.0.2",
    "key-forge": "~0.1.3",
    "pirate": "~0.9.7",
    "redis": "0.8.x",
    "typely": "0.0.x"
  },
  "devDependencies": {
    "testify": "0.2.9",
    "express": "~3.3.5"
  },
  "contributors": [],
  "readme": "# Mutual\n\nMutual is inspired by Scala's Actor model. Concurrency is managed by setting up Channels between participants. Remote channels are implemented by using Redis as a transport. Event channels provide an `EventEmitter` like interface. Builder methods, in combination with event-bubbling, can be used to build complex chains of asynchronous processing.\n\n    fs = require \"fs\"\n    \n    {EventChannel} = require \"mutual\"\n    events = new EventChannel\n    \n    # all error events will bubble-up here\n    events.on \"error\", (error) -> console.log error\n    \n    # wrap a Node-style callback function\n    read = events.wrap(fs.readFile)\n    \n    # use builder function to create an asynchronous control flow\n    do events.serially (go) ->\n      go -> read(\"foo.txt\", encoding: \"utf8\")\n      go (text) -> console.log text\n      \nRemote channels are just event channels, which means you can swap them out without changing any code. Here's a simple express app that implements a chat interface:\n\n    http = require \"http\"\n    {EventChannel} = require \"mutual\"\n    events = new EventChannel\n\n    # all error events will bubble-up here\n    events.on \"error\", (error) -> console.log error\n\n    {getChannel,makeChannel} = do (channels = {}) ->\n      makeChannel: (name) -> events.source name\n      getChannel: (name) -> channels[name] ?= makeChannel(name)\n\n    express = require \"express\"\n    app = express()\n\n    app.use (request, response, next) -> \n      body = \"\"\n      request.on \"data\", (data) -> body += data\n      request.on \"end\", ->\n        request.body = body\n        next()\n\n    app.get '/:channel', (request, response) ->\n      {channel} = request.params\n      getChannel(channel).once \"message\", (message) ->\n        response.send message\n\n    app.post '/:channel', (request, response) ->\n      response.send 202, \"\"\n      {channel} = request.params\n      message = request.body\n      getChannel(channel).emit \"message\", message\n\n    http.createServer(app).listen(1337)\n    \nIf you run this, you can do a GET to a channel URL (ex: `/foo`) and then POST a message to it.\n\n        curl http://localhost:1337/foo &\n        curl http://localhost:1337/foo -d \"Hello\"\n\nThe original GET will return the message.\n\nOf course, this isn't much different from what we could do using `EventEmitter`, outside of utilizing the event bubbling for `error` events. However, this version also has a big limitation: it only works for one process. If we start to get lots of messages, we'll want to be able to run multiple processes, perhaps even across multiple machines.\n\nWith Mutual, all we need to do, basically, is change `makeChannel` so that it returns a `RemoteChannel`. \n\nFirst, let's `require` the `RedisTransport` and `RemoteChannel`:\n\n    {RemoteChannel,EventChannel,RedisTransport} = require \"../src/index\"\n\nNext, well instantiate the transport:\n\n    transport = new RedisTransport host: \"localhost\", port: 6379\n    \nFinally, we just change our `makeChannel` function:\n\n    makeChannel: (name) -> \n      channel = new RemoteChannel {name,transport}\n      channel.forward(events, name)\n      channel.listen()\n      channel\n\nThe rest of our code remains the same. We've just moved to an implementation that will work across multiple process or machine boundaries by adding and modifying a few lines of code. The bulk of our application is unchanged.\n\nOur final version of our little chat API can be found [in the examples][ex].\n\n[ex]:https://github.com/dyoder/mutual/tree/master/examples\n\n## Installation\n\n    npm install mutual\n    \n## Status\n\nIn development - the interface is relatively stable, but we haven't done a lot of load and performance testing.\n",
  "bugs": {
    "url": "https://github.com/dyoder/mutual/issues"
  },
  "homepage": "https://github.com/dyoder/mutual",
  "_id": "mutual@0.4.16",
  "_shasum": "dad7929eace3b85da82b716c2612745241e2bdf3",
  "_from": "mutual@0.4.x",
  "_resolved": "https://registry.npmjs.org/mutual/-/mutual-0.4.16.tgz"
}
