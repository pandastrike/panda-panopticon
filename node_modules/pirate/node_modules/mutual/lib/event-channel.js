// Generated by CoffeeScript 1.7.1
(function() {
  var Attributes, Channel, EventChannel, PatternSet, include, merge, overload, type, w, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ref = require("fairmont"), include = _ref.include, Attributes = _ref.Attributes, merge = _ref.merge, type = _ref.type, w = _ref.w;

  Channel = require("./channel");

  PatternSet = require("./pattern-set");

  overload = require("typely").overload;

  EventChannel = (function(_super) {
    __extends(EventChannel, _super);

    include(EventChannel, Attributes);

    function EventChannel() {
      this.callback = __bind(this.callback, this);
      EventChannel.__super__.constructor.apply(this, arguments);
      this.channels = {};
      this._patterns = new PatternSet;
      this.receive((function(_this) {
        return function(message) {
          return _this._patterns.match(message.event, function(event) {
            var _ref1;
            return (_ref1 = _this.channels[event]) != null ? _ref1.fire(message.content) : void 0;
          });
        };
      })(this));
    }

    EventChannel.prototype.on = overload(function(match, fail) {
      match("string", "function", function(name, handler) {
        var _base;
        this._patterns.add(name);
        if ((_base = this.channels)[name] == null) {
          _base[name] = new Channel;
        }
        this.channels[name].receive(handler);
        return this;
      });
      match("object", function(handlers) {
        var handler, name;
        for (name in handlers) {
          handler = handlers[name];
          this.on(name, handler);
        }
        return this;
      });
      return fail(function() {
        throw new TypeError("Invalid event handler specified");
      });
    });

    EventChannel.prototype.once = overload(function(match, fail) {
      match("string", "function", function(name, handler) {
        var _handler;
        _handler = (function(_this) {
          return function() {
            var args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            handler.apply(null, args);
            return _this.remove(name, _handler);
          };
        })(this);
        this.on(name, _handler);
        return this;
      });
      match("object", function(handlers) {
        var handler, name;
        for (name in handlers) {
          handler = handlers[name];
          this.once(name, handler);
        }
        return this;
      });
      return fail(function() {
        throw new TypeError("Invalid event handler specified");
      });
    });

    EventChannel.prototype.emit = function(name, content) {
      return this.send({
        event: name,
        content: content
      });
    };

    EventChannel.prototype.forward = function(channel, name) {
      return this.receive((function(_this) {
        return function(message) {
          if (name != null) {
            message = merge(message, {
              event: "" + name + "." + message.event
            });
          }
          return channel.fire(message);
        };
      })(this));
    };

    EventChannel.prototype.source = function() {
      var _source;
      _source = function(name, block) {
        var channel;
        channel = new this.constructor;
        channel.forward(this, name);
        if (block != null) {
          block(channel);
        }
        return channel;
      };
      this.source = overload(function(match, fail) {
        match(function() {
          return EventChannel.__super__.source.apply(this, arguments);
        });
        match("function", function(fn) {
          return EventChannel.__super__.source.apply(this, arguments);
        });
        match("string", _source);
        match("string", "function", _source);
        return fail(function() {
          throw new TypeError("Invalid event source specified");
        });
      });
      return this.source.apply(this, arguments);
    };

    EventChannel.prototype.remove = function(event, handler) {
      var _ref1;
      return (_ref1 = this.channels[event]) != null ? _ref1.remove(handler) : void 0;
    };

    EventChannel.prototype.callback = function() {
      var error, results;
      error = arguments[0], results = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (error == null) {
        return this.emit.apply(this, ["success"].concat(__slice.call(results)));
      } else {
        return this.emit("error", error);
      }
    };

    EventChannel.prototype.emitter = function(emitter) {
      var emit, self;
      self = this;
      emit = emitter.emit;
      emitter.emit = function() {
        var args, event;
        event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        emit.call.apply(emit, [this, event].concat(__slice.call(args)));
        args = (function() {
          switch (args.length) {
            case 0:
              return null;
            case 1:
              return args[0];
            default:
              return args;
          }
        })();
        return self.emit(event, args);
      };
      return emitter;
    };

    EventChannel.prototype.safely = function(fn) {
      var error;
      try {
        return fn();
      } catch (_error) {
        error = _error;
        return this.emit("error", error);
      }
    };

    EventChannel.prototype.serially = function() {
      var accumulate, args, builder, events, functions, go, _ref1;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 2) {
        (_ref1 = args[0], accumulate = _ref1.accumulate), builder = args[1];
      } else {
        builder = args[0];
        accumulate = false;
      }
      functions = [];
      go = function(fn) {
        return functions.push(fn);
      };
      builder(go);
      events = this.source();
      return function(arg) {
        var count, results, _fn;
        results = [];
        count = 0;
        _fn = function(arg) {
          var error, fn, result, rval;
          if (arg != null) {
            results.push(arg);
          }
          fn = functions.shift();
          if (fn != null) {
            count++;
            try {
              rval = fn(arg);
              if (rval instanceof EventChannel) {
                rval.on("success", _fn);
                return rval.on("error", function(error) {
                  return events.emit("error", error);
                });
              } else {
                return _fn(rval);
              }
            } catch (_error) {
              error = _error;
              return events.emit("error", error);
            }
          } else {
            if (accumulate === true) {
              return events.emit("success", results);
            } else {
              result = results[results.length - 1];
              return events.emit("success", result);
            }
          }
        };
        _fn(arg);
        return events;
      };
    };

    EventChannel.prototype.concurrently = function(builder) {
      var events, functions, go;
      functions = [];
      go = function(name, fn) {
        return functions.push((fn != null ? [name, fn] : [null, name]));
      };
      builder(go);
      events = this.source();
      return function(arg) {
        var _fn;
        _fn = function(arg) {
          var called, errors, finish, fn, name, record_error, results, returned, _i, _len, _ref1, _results;
          results = {};
          errors = {};
          called = 0;
          returned = 0;
          finish = function() {
            var _error;
            returned++;
            if (called === returned) {
              if (Object.keys(errors).length === 0) {
                return events.emit("success", results);
              } else {
                _error = new Error("concurrently: unable to complete");
                _error.errors = errors;
                return events.emit("error", _error);
              }
            }
          };
          record_error = function(name, _error) {
            if (name) {
              errors[name] = _error;
            } else {
              errors.unnamed_actions || (errors.unnamed_actions = []);
              errors.unnamed_actions.push(_error);
            }
            return finish();
          };
          if (functions.length === 0) {
            return arg;
          }
          _results = [];
          for (_i = 0, _len = functions.length; _i < _len; _i++) {
            _ref1 = functions[_i], name = _ref1[0], fn = _ref1[1];
            _results.push((function(name, fn) {
              var rval, success, _error;
              success = function(result) {
                if (name != null) {
                  results[name] = result;
                }
                return finish();
              };
              try {
                called++;
                rval = fn(arg);
                if (rval instanceof EventChannel) {
                  rval.on("success", success);
                  return rval.on("error", function(error) {
                    return record_error(name, error);
                  });
                } else {
                  return success(rval);
                }
              } catch (_error) {
                _error = _error;
                return record_error(name, _error);
              }
            })(name, fn));
          }
          return _results;
        };
        _fn(arg);
        return events;
      };
    };

    EventChannel.prototype.wrap = function() {
      var fn, fns, rval;
      fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      rval = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = fns.length; _i < _len; _i++) {
          fn = fns[_i];
          _results.push((function(_this) {
            return function() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return _this.source(function(events) {
                var series;
                series = _this.serially({
                  accumulate: true
                }, function(step) {
                  var arg, i, _j, _len1, _results1;
                  _results1 = [];
                  for (i = _j = 0, _len1 = args.length; _j < _len1; i = ++_j) {
                    arg = args[i];
                    _results1.push((function(arg) {
                      return step(function() {
                        return arg;
                      });
                    })(arg));
                  }
                  return _results1;
                })();
                series.on("error", function(error) {
                  return events.emit("error", error);
                });
                return series.on("success", function(results) {
                  return fn.apply(null, __slice.call(results).concat([events.callback]));
                });
              });
            };
          })(this));
        }
        return _results;
      }).call(this);
      if (rval.length < 2) {
        return rval[0];
      } else {
        return rval;
      }
    };

    EventChannel.prototype.sleep = function(ms) {
      return this.source(function(events) {
        return setTimeout((function() {
          return events.emit("success");
        }), ms);
      });
    };

    return EventChannel;

  })(Channel);

  module.exports = EventChannel;

}).call(this);
