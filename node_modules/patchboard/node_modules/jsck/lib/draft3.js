// Generated by CoffeeScript 1.6.3
var Context, Runtime, URI, Validator, attributes, deap, escape,
  __slice = [].slice;

URI = require("./uri");

deap = require("deap");

attributes = require("./draft3/attributes");

escape = function(string) {
  return string.replace(/~0/g, "~").replace(/~1/g, "/").replace(/%25/g, "%");
};

Runtime = (function() {
  function Runtime(_arg) {
    this.errors = _arg.errors, this.pointer = _arg.pointer;
  }

  Runtime.prototype.child = function(token) {
    return new this.constructor({
      errors: this.errors,
      pointer: "" + this.pointer + "/" + token
    });
  };

  Runtime.prototype.error = function(context) {
    return this.errors.push({
      document: {
        pointer: this.pointer
      },
      schema: {
        pointer: context.pointer
      }
    });
  };

  return Runtime;

})();

Context = (function() {
  function Context(_arg) {
    this.pointer = _arg.pointer, this.scope = _arg.scope;
  }

  Context.prototype.child = function(token) {
    return new Context({
      pointer: "" + this.pointer + "/" + token,
      scope: this.scope
    });
  };

  Context.prototype.sibling = function(token) {
    var pointer;
    pointer = this.pointer.replace(/\/.*$/, "/" + token);
    return new Context({
      pointer: pointer,
      scope: this.scope
    });
  };

  return Context;

})();

module.exports = Validator = (function() {
  var m, method, module_name, modules, name, _i, _len;

  modules = ["type", "numeric", "comparison", "arrays", "objects", "strings"];

  for (_i = 0, _len = modules.length; _i < _len; _i++) {
    module_name = modules[_i];
    m = require("./draft3/" + module_name);
    for (name in m) {
      method = m[name];
      Validator.prototype[name] = method;
    }
  }

  function Validator() {
    var schema, schemas, _j, _len1;
    schemas = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.uris = {};
    this.media_types = {};
    this.unresolved = {};
    for (_j = 0, _len1 = schemas.length; _j < _len1; _j++) {
      schema = schemas[_j];
      this.add(schema);
    }
  }

  Validator.prototype.add = function(schema) {
    var context, found_schema, key, pointers, ref, scope, uri, _ref, _ref1;
    schema = deap.clone(schema);
    if (schema.id) {
      schema.id = schema.id.replace(/#?$/, "#");
    }
    context = new Context({
      pointer: schema.id || "#",
      scope: schema.id || "#"
    });
    this.compile_references(schema, context);
    _ref = this.unresolved;
    for (ref in _ref) {
      _ref1 = _ref[ref], scope = _ref1.scope, uri = _ref1.uri;
      if (found_schema = this.resolve_ref(uri, scope)) {
        delete this.unresolved[ref];
        this.register(ref, found_schema);
      }
    }
    if (Object.keys(this.unresolved).length > 0) {
      pointers = (function() {
        var _ref2, _results;
        _ref2 = this.unresolved;
        _results = [];
        for (key in _ref2) {
          uri = _ref2[key].uri;
          _results.push(uri);
        }
        return _results;
      }).call(this);
      throw new Error("Unresolvable $ref values: " + (JSON.stringify(pointers)));
    }
    return this.compile(schema, context);
  };

  Validator.prototype.register = function(uri, schema) {
    var media_type;
    this.uris[uri] = schema;
    if (media_type = schema.mediaType) {
      if (media_type !== "application/json") {
        return this.media_types[media_type] = schema;
      }
    }
  };

  Validator.prototype.validate = function(data) {
    return this.validator("#").validate(data);
  };

  Validator.prototype.validator = function(arg) {
    var schema,
      _this = this;
    if (schema = this.find(arg)) {
      return {
        validate: function(data) {
          var attribute, base, error, errors, pointer, runtime, valid, _j, _k, _len1, _ref, _ref1;
          errors = [];
          runtime = new Runtime({
            errors: errors,
            pointer: "#"
          });
          schema._test(data, runtime);
          if (errors.length > 0) {
            for (_j = 0, _len1 = errors.length; _j < _len1; _j++) {
              error = errors[_j];
              _ref = error.schema.pointer.split("/"), base = 2 <= _ref.length ? __slice.call(_ref, 0, _k = _ref.length - 1) : (_k = 0, []), attribute = _ref[_k++];
              pointer = base.join("/");
              error.schema.definition = (_ref1 = _this.resolve_ref(pointer)) != null ? _ref1[attribute] : void 0;
            }
          }
          valid = runtime.errors.length === 0;
          return {
            valid: valid,
            errors: errors
          };
        },
        toJSON: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return schema;
        }
      };
    } else {
      throw new Error("No schema found for '" + (JSON.stringify(arg)) + "'");
    }
  };

  Validator.prototype.find = function(arg) {
    var media_type, uri;
    if (this.test_type("string", arg)) {
      uri = escape(arg);
      return this.uris[uri];
    } else if (uri = arg.uri) {
      uri = escape(uri);
      return this.uris[uri];
    } else if (media_type = arg.mediaType) {
      return this.media_types[media_type];
    } else {
      return null;
    }
  };

  Validator.prototype.resolve_ref = function(uri, scope) {
    var schema;
    if (schema = this.find(uri)) {
      if (schema.$ref) {
        uri = URI.resolve(scope, schema.$ref);
        return this.resolve_ref(uri);
      } else {
        return schema;
      }
    } else {
      return null;
    }
  };

  Validator.prototype.compile_references = function(schema, context) {
    var attribute, definition, new_context, pointer, scope, uri, _results;
    scope = context.scope, pointer = context.pointer;
    this.register(pointer, schema);
    if (schema.id && schema.id.indexOf("#") === 0) {
      uri = URI.resolve(scope, schema.id);
      schema.id = uri;
      this.register(uri, schema);
    }
    if (this.test_type("object", schema)) {
      _results = [];
      for (attribute in schema) {
        definition = schema[attribute];
        new_context = context.child(attribute);
        switch (attribute) {
          case "$ref":
            uri = URI.resolve(scope, definition);
            if (pointer.indexOf(uri + "/") !== 0) {
              schema.$ref = uri;
              if (schema = this.resolve_ref(uri, scope)) {
                _results.push(this.compile_references(schema, context));
              } else {
                _results.push(this.unresolved[pointer] = {
                  scope: context.scope,
                  uri: uri
                });
              }
            } else {
              _results.push(void 0);
            }
            break;
          case "type":
            if (this.test_type("array", definition)) {
              _results.push(this.type_refs(definition, new_context));
            } else {
              _results.push(void 0);
            }
            break;
          case "properties":
          case "patternProperties":
            _results.push(this.dictionary_refs(definition, new_context));
            break;
          case "items":
            _results.push(this.items_refs(definition, new_context));
            break;
          case "additionalItems":
          case "additionalProperties":
          case "extends":
            _results.push(this.compile_references(definition, context.child(attribute)));
            break;
          default:
            if (!attributes[attribute] && this.test_type("object", definition)) {
              _results.push(this.compile_references(definition, context.child(attribute)));
            } else {
              _results.push(void 0);
            }
        }
      }
      return _results;
    }
  };

  Validator.prototype.type_refs = function(union, context) {
    var i, schema, _j, _len1, _results;
    _results = [];
    for (i = _j = 0, _len1 = union.length; _j < _len1; i = ++_j) {
      schema = union[i];
      if (this.test_type("object", schema)) {
        _results.push(this.compile_references(schema, context.child(i.toString())));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Validator.prototype.dictionary_refs = function(properties, context) {
    var key, schema, _results;
    _results = [];
    for (key in properties) {
      schema = properties[key];
      _results.push(this.compile_references(schema, context.child(key)));
    }
    return _results;
  };

  Validator.prototype.items_refs = function(definition, context) {
    var def, i, _j, _len1, _results;
    if (this.test_type("array", definition)) {
      _results = [];
      for (i = _j = 0, _len1 = definition.length; _j < _len1; i = ++_j) {
        def = definition[i];
        _results.push(this.compile_references(def, context.child(i.toString())));
      }
      return _results;
    } else {
      return this.compile_references(definition, context);
    }
  };

  Validator.prototype.compile = function(schema, context) {
    var attribute, definition, extended, key, new_context, pointer, ref, scope, spec, test, test_function, tests, uri, _j, _len1, _ref, _ref1, _ref2,
      _this = this;
    scope = context.scope, pointer = context.pointer;
    tests = [];
    if (uri = schema.$ref) {
      uri = URI.resolve(scope, uri);
      if (pointer.indexOf(uri) === 0) {
        return this.recursive_test(schema, context);
      }
      schema = this.find(uri);
      if (!schema) {
        throw new Error("No schema found for $ref '" + uri + "'");
      }
    }
    if (extended = schema["extends"]) {
      if (ref = extended.$ref) {
        uri = URI.resolve(scope, ref);
        extended = this.find(uri);
        if (!extended) {
          throw new Error("No schema found for $ref '" + ref + "'");
        }
      }
      delete schema["extends"];
      if (this.test_type("array", extended)) {
        deap.merge.apply(deap, [schema].concat(__slice.call(extended)));
      } else {
        deap.merge(schema, extended);
      }
    }
    for (attribute in schema) {
      definition = schema[attribute];
      if (spec = attributes[attribute]) {
        if (!spec.ignore) {
          new_context = context.child(attribute);
          new_context.modifiers = {};
          if (spec.modifiers) {
            _ref = spec.modifiers;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              key = _ref[_j];
              new_context.modifiers[key] = schema[key];
            }
          }
          if (test = this[attribute](definition, new_context)) {
            test.pointer = new_context.pointer;
            tests.push(test);
          }
        }
      } else {
        if (this.test_type("object", definition)) {
          this.compile(definition, context.child(attribute));
        }
      }
    }
    test_function = function(data, runtime) {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = tests.length; _k < _len2; _k++) {
        test = tests[_k];
        _results.push(test(data, runtime));
      }
      return _results;
    };
    if (schema.id) {
      uri = URI.resolve(scope, schema.id);
      if ((_ref1 = this.find(uri)) != null) {
        _ref1._test = test_function;
      }
    }
    if ((_ref2 = this.find(pointer)) != null) {
      _ref2._test = test_function;
    }
    return test_function;
  };

  Validator.prototype.recursive_test = function(schema, _arg) {
    var pointer, scope, uri,
      _this = this;
    scope = _arg.scope, pointer = _arg.pointer;
    uri = URI.resolve(scope, schema.$ref);
    if (schema = this.find(uri)) {
      return function(data, runtime) {
        return schema._test(data, runtime);
      };
    } else {
      throw new Error("No schema found for $ref '" + uri + "'");
    }
  };

  return Validator;

})();
